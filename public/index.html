<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Shopify Inventory Scanner</title>
  <script src="https://unpkg.com/@zxing/library@latest"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #fff;
      color: #111;
    }
    .container {
      max-width: 800px;
      margin: auto;
    }
    .status {
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 5px;
    }
    .status.success { background: #e0ffe0; color: #1a8e1a; }
    .status.error { background: #ffe0e0; color: #d22; }
    .status.scanning { background: #e0f0ff; color: #0056b3; }

    .product-image {
      max-width: 150px;
      max-height: 150px;
    }
    
    .inventory-table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
      margin-top: 15px;
      font-size: 0.8em;
    }
    
    .inventory-table th,
    .inventory-table td {
      border: 1px solid #ccc;
      padding: 4px 2px;
      text-align: center;
      word-break: break-word;
      overflow: hidden;
    }

    .inventory-table th:first-child,
    .inventory-table td:first-child {
      width: 15%;
      font-weight: bold;
    }

    .inventory-table th:not(:first-child):not(:last-child),
    .inventory-table td:not(:first-child):not(:last-child) {
      width: 18%;
    }

    .inventory-table th:last-child,
    .inventory-table td:last-child {
      width: 13%;
      font-weight: bold;
    }

    .inventory-table th {
      background-color: #f5f5f5;
      font-weight: bold;
      font-size: 0.75em;
    }

    /* Mobile responsive adjustments */
    @media (max-width: 768px) {
      .container {
        padding: 10px;
        margin: 0;
      }
      
      .inventory-table {
        font-size: 0.7em;
      }
      
      .inventory-table th,
      .inventory-table td {
        padding: 3px 1px;
      }
      
      .inventory-table th {
        font-size: 0.65em;
      }
      
      .product-image {
        max-width: 120px;
        max-height: 120px;
      }
      
      body {
        padding: 10px;
      }
      
      h1 {
        font-size: 1.3em;
        margin-bottom: 15px;
      }
    }

    .stock-zero { color: red; font-weight: bold; }
    .stock-low { color: orange; font-weight: bold; }
    .stock-medium { color: #888; font-weight: bold; }
    .stock-high { color: green; font-weight: bold; }

    #cameraContainer {
      display: none;
      margin-top: 15px;
      position: relative;
    }

    video {
      width: 100%;
      max-width: 400px;
      border: 2px solid #ddd;
      border-radius: 5px;
      cursor: pointer;
    }

    .focus-indicator {
      position: absolute;
      width: 60px;
      height: 60px;
      border: 2px solid #00ff00;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .scan-zone {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 250px;
      height: 80px;
      border: 2px dashed #ff0000;
      border-radius: 5px;
      pointer-events: none;
    }

    .camera-instructions {
      text-align: center;
      margin-top: 10px;
      font-size: 0.9em;
      color: #666;
    }

    .btn-success {
      background: #28a745;
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
      margin-right: 10px;
    }

    .btn-danger {
      background: #dc3545;
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }

    .price-block {
      font-size: 1.2em;
      margin: 0.5em 0;
    }
    
    .price-block s {
      margin-left: 8px;
      color: #999;
    }

    input[type="text"] {
      width: 100%;
      padding: 12px;
      font-size: 1.1em;
      border: 2px solid #ddd;
      border-radius: 5px;
      margin-bottom: 15px;
    }

    input[type="text"]:focus {
      border-color: #007bff;
      outline: none;
    }
    
  </style>
</head>
<body>
  <div class="container">
    <h1>üè™ Store Inventory Scanner</h1>

    <input id="barcodeInput" type="text" placeholder="Enter or scan barcode" />

    <div style="margin-bottom: 15px;">
      <button class="btn-success" onclick="lookupBarcode()">üîç Lookup Barcode</button>
      <button class="btn-success" onclick="startCamera()">üì∑ Start Camera</button>
      <button id="stopBtn" class="btn-danger" style="display: none;" onclick="stopCamera()">üõë Stop Camera</button>
    </div>

    <div style="margin-bottom: 10px; padding: 10px; background: #f0f8ff; border-radius: 5px; font-size: 0.9em;">
      üí° <strong>Tip:</strong> If camera scanning is slow, try typing the barcode manually or use a dedicated barcode scanner.
    </div>

    <div id="status" class="status scanning" style="display:none;"></div>

    <div id="cameraContainer">
      <video id="video" autoplay muted playsinline></video>
      <div class="scan-zone"></div>
      <div class="focus-indicator" id="focusIndicator"></div>
      <div class="camera-instructions">
        üì± Tap on the video to focus ‚Ä¢ Hold barcode steady in red box
      </div>
    </div>

    <div id="product" style="margin-top: 20px; display: none;"></div>
  </div>

  <script>
    const BACKEND_URL = 'https://ybbc.onrender.com';

    const video = document.getElementById("video");
    const cameraContainer = document.getElementById("cameraContainer");
    const statusDiv = document.getElementById("status");
    const stopBtn = document.getElementById("stopBtn");
    const productDiv = document.getElementById("product");
    const focusIndicator = document.getElementById("focusIndicator");

    let codeReader = new ZXing.BrowserBarcodeReader();
    let scanCooldown = false;
    let currentStream = null;
    let currentTrack = null;

    window.onload = () => {
      document.getElementById("barcodeInput").focus();
    };

    document.getElementById("barcodeInput").addEventListener("keydown", function(event) {
      if (event.key === "Enter") {
        lookupBarcode();
      }
    });

    window.addEventListener('beforeunload', stopCamera);

    function showStatus(message, type = 'scanning') {
      statusDiv.textContent = message;
      statusDiv.className = `status ${type}`;
      statusDiv.style.display = 'block';
    }

    function hideStatus() {
      statusDiv.style.display = 'none';
    }

    async function lookupBarcode() {
      const barcode = document.getElementById("barcodeInput").value.trim();
      if (!barcode) return;

      showStatus("üîç Looking up " + barcode + "...", 'scanning');

      try {
        const res = await fetch(`${BACKEND_URL}/lookup`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ barcode })
        });

        if (!res.ok) {
          const errorData = await res.json();
          showStatus("‚ùå " + (errorData.error || "Product not found"), 'error');
          return;
        }

        const data = await res.json();
        displayProduct(data);
        showStatus("‚úÖ Product found!", 'success');
        setTimeout(hideStatus, 3000);

        document.getElementById("barcodeInput").value = "";
        document.getElementById("barcodeInput").focus();
      } catch (err) {
        showStatus("‚ùå Network error", 'error');
        console.error('Lookup error:', err);
      }
    }

    function getStockClass(quantity) {
      if (quantity === 0) return 'stock-zero';
      if (quantity <= 2) return 'stock-low';
      if (quantity <= 5) return 'stock-medium';
      return 'stock-high';
    }

    function displayProduct(data) {
      const variants = data.variants || [];
      const locations = ["Bogota", "Cedarhurst", "Teaneck Store", "Toms River"];

      let lowestPrice = null;
      let lowestCompareAt = null;

      // Prepare matrix
      const matrixRows = variants.map(v => {
        const row = {
          size: v.size || v.variantTitle || 'Unknown',
          price: parseFloat(v.price),
          compareAtPrice: parseFloat(v.compareAtPrice || 0),
          quantities: {},
          total: 0
        };

        locations.forEach(loc => row.quantities[loc] = 0);

        v.inventory.forEach(entry => {
          if (locations.includes(entry.location)) {
            row.quantities[entry.location] = entry.quantity || 0;
            row.total += entry.quantity || 0;
          }
        });

        // Track lowest price
        if (!isNaN(row.price) && (lowestPrice === null || row.price < lowestPrice)) {
          lowestPrice = row.price;
          lowestCompareAt = !isNaN(row.compareAtPrice) ? row.compareAtPrice : null;
        }

        return row;
      });

      // Calculate totals by location
      const locationTotals = {};
      locations.forEach(loc => {
        locationTotals[loc] = matrixRows.reduce((sum, row) => sum + row.quantities[loc], 0);
      });
      const grandTotal = Object.values(locationTotals).reduce((sum, total) => sum + total, 0);

      // Table
      let tableHTML = `
        <table class="inventory-table">
          <thead>
            <tr>
              <th style="min-width: 60px;">Size</th>
              ${locations.map(loc => `<th style="min-width: 80px;">${loc}</th>`).join('')}
              <th style="min-width: 60px;">Total</th>
            </tr>
          </thead>
          <tbody>
      `;

      matrixRows.forEach(row => {
        tableHTML += `<tr><td><strong>${row.size}</strong></td>`;
        locations.forEach(loc => {
          const qty = row.quantities[loc];
          tableHTML += `<td class="${getStockClass(qty)}">${qty}</td>`;
        });
        tableHTML += `<td><strong>${row.total}</strong></td></tr>`;
      });

      // Add totals row
      tableHTML += `<tr style="background-color: #f0f0f0;"><td><strong>TOTAL</strong></td>`;
      locations.forEach(loc => {
        tableHTML += `<td><strong>${locationTotals[loc]}</strong></td>`;
      });
      tableHTML += `<td><strong>${grandTotal}</strong></td></tr>`;

      tableHTML += `</tbody></table>`;

      let priceHTML = '';
      if (lowestCompareAt && lowestCompareAt > lowestPrice) {
        priceHTML = `<div class="price-block"><strong>$${lowestPrice.toFixed(2)}</strong> <s>$${lowestCompareAt.toFixed(2)}</s></div>`;
      } else if (lowestPrice !== null) {
        priceHTML = `<div class="price-block"><strong>$${lowestPrice.toFixed(2)}</strong></div>`;
      }

      productDiv.innerHTML = `
        <div style="margin-bottom: 1em;">
          <img src="${data.image}" class="product-image" alt="Product image" style="float: right; margin-left: 15px;" />
          <strong style="font-size: 1.3em;">${data.title}</strong><br>
          ${priceHTML}
          <div style="clear: both;"></div>
        </div>
        ${tableHTML}
      `;
      productDiv.style.display = "block";
    }

    // Add tap-to-focus functionality
    video.addEventListener('click', async (event) => {
      if (!currentTrack) return;

      try {
        const rect = video.getBoundingClientRect();
        const x = (event.clientX - rect.left) / rect.width;
        const y = (event.clientY - rect.top) / rect.height;

        // Show focus indicator
        const indicator = focusIndicator;
        indicator.style.left = (event.clientX - rect.left - 30) + 'px';
        indicator.style.top = (event.clientY - rect.top - 30) + 'px';
        indicator.style.opacity = '1';

        // Apply focus constraints
        const capabilities = currentTrack.getCapabilities();
        
        if (capabilities.focusMode && capabilities.focusMode.includes('manual')) {
          await currentTrack.applyConstraints({
            advanced: [{
              focusMode: 'manual',
              pointsOfInterest: [{ x: x, y: y }]
            }]
          });
        } else if (capabilities.focusMode && capabilities.focusMode.includes('single-shot')) {
          await currentTrack.applyConstraints({
            advanced: [{
              focusMode: 'single-shot',
              pointsOfInterest: [{ x: x, y: y }]
            }]
          });
        } else {
          // Fallback: try to refocus by toggling focus mode
          await currentTrack.applyConstraints({
            advanced: [{
              focusMode: 'continuous'
            }]
          });
        }

        // Hide indicator after a delay
        setTimeout(() => {
          indicator.style.opacity = '0';
        }, 500);

        showStatus("üì± Focusing...", 'scanning');
        setTimeout(() => {
          if (currentStream) showStatus("üì± Ready to scan...", 'scanning');
        }, 1000);

      } catch (error) {
        console.log('Focus failed:', error);
        // Fallback: just show the focus indicator for user feedback
        setTimeout(() => {
          focusIndicator.style.opacity = '0';
        }, 500);
      }
    });

    async function startCamera() {
      try {
        showStatus("üì∑ Starting camera...", 'scanning');
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        let backCamera = videoDevices.find(device => /back|rear|environment/i.test(device.label));
        if (!backCamera && videoDevices.length > 0) backCamera = videoDevices[0];

        currentStream = await navigator.mediaDevices.getUserMedia({
          video: {
            deviceId: backCamera.deviceId ? { exact: backCamera.deviceId } : undefined,
            facingMode: backCamera.deviceId ? undefined : { ideal: 'environment' },
            width: { ideal: 1280, min: 640 },
            height: { ideal: 720, min: 480 },
            focusMode: { ideal: 'continuous' },
            exposureMode: { ideal: 'continuous' },
            whiteBalanceMode: { ideal: 'continuous' }
          }
        });

        // Get the video track for focus control
        currentTrack = currentStream.getVideoTracks()[0];

        video.srcObject = currentStream;
        cameraContainer.style.display = "block";
        stopBtn.style.display = "inline-block";

        showStatus("üì± Point camera at barcode ‚Ä¢ Tap to focus", 'scanning');

        codeReader.decodeFromVideoDevice(backCamera.deviceId, 'video', async result => {
          if (result && !scanCooldown) {
            scanCooldown = true;
            document.getElementById("barcodeInput").value = result.text;
            showStatus("‚úÖ Barcode detected: " + result.text, 'success');
            await lookupBarcode();
            setTimeout(() => {
              scanCooldown = false;
              if (currentStream) showStatus("üì± Ready to scan ‚Ä¢ Tap to focus", 'scanning');
            }, 3000);
          }
        });
      } catch (err) {
        console.error('Camera start error:', err);
        showStatus("‚ùå Camera access failed", 'error');
      }
    }

    function stopCamera() {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
        currentStream = null;
        currentTrack = null;
      }
      cameraContainer.style.display = "none";
      stopBtn.style.display = "none";
      focusIndicator.style.opacity = "0";
      hideStatus();
    }
  </script>
</body>
</html>
